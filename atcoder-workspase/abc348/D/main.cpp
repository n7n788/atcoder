#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <bitset>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>
#include <cassert>
#include <iomanip>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)
#define FOR(i, a, b) for (int i = (a), i##_len = (b); i <= i##_len; ++i)
#define REV(i, a, b) for (int i = (a); i >= (b); --i)
#define CLR(a, b) memset((a), (b), sizeof(a))
#define DUMP(x) cout << #x << " = " << (x) << endl;
#define INF_ll 1001001001001001001ll
#define INF 1001001001
#define fcout cout << fixed << setprecision(12)

using ll = long long;
using vi = vector<int>;
using vl = vector<long long>;
using vs = vector<string>;
using vc = vector<char>;
using vb = vector<bool>;
using vpii = vector<pair<int, int>>;
using vpll = vector<pair<long long, long long>>;
using vvi = vector<vector<int>>;
using vvl = vector<vector<long long>>;
using vvc = vector<vector<char>>;
using vvb = vector<vector<bool>>;
using vvvi = vector<vector<vector<int>>>;
using pii = pair<int, int>;

template <typename T>
inline bool chmax(T &a, T b) {
    return ((a < b) ? (a = b, true) : (false));
}
template <typename T>
inline bool chmin(T &a, T b) {
    return ((a > b) ? (a = b, true) : (false));
}

const string YES = "Yes";
const string NO = "No";

using P = pair<int, int>;
vector<int> Dr = {1, 0, -1, 0};
vector<int> Dc = {0, 1, 0, -1};

struct Med {
    int r, c, e;
    Med(int r = 0, int c = 0, int e = 0): r(r), c(c), e(e) {}
};

int main()
{
    int h, w, n;
    cin >> h >> w;
    vs field(h);
    REP(i, h) cin >> field.at(i);
    cin >> n;
    vector<Med> meds(n);
    REP(i, n) {
        int r, c, e;
        cin >> r >> c >> e;
        r--; c--;
        meds.at(i) = {r, c, e};
    }

    // 始点と終点の位置求め, medsに追加
    int si, sj, ti, tj;
    REP(i, h) REP(j, w) {
        if (field.at(i).at(j) == 'S') si = i, sj = j;
        else if (field.at(i).at(j) == 'T') ti = i, tj = j;
    }
    n += 2;
    vvi edges(n);
    meds.emplace_back(si, sj, 0);
    meds.emplace_back(ti, tj, 0);

    // 各頂点iについて他頂点への最短経路を求め、辺を張るかどうかチェック
    REP(i, n) {
        auto [sr, sc, se] = meds.at(i);
        vvi d(h, vi(w, INF));
        queue<P> q;
        q.emplace(sr, sc);
        d.at(sr).at(sc) = 0;
        while (!q.empty()) {
            auto [r, c] = q.front(); q.pop();
            REP(j, 4) {
                int nr = r + Dr.at(j);
                int nc = c + Dc.at(j);
                if (0 <= nr && nr < h && 0 <= nc && nc < w && 
                    field.at(nr).at(nc) != '#' &&
                    d.at(nr).at(nc) == INF) {
                    q.emplace(nr, nc);
                    d.at(nr).at(nc) = d.at(r).at(c) + 1;
                }
            }
        }
        REP(j, n) {
            if (i == j) continue;
            auto [tr, tc, te] = meds.at(j);
            if (d.at(tr).at(tc) <= se) edges.at(i).push_back(j);
        }
    }

    // BFSを実行し、頂点n-2からn-1へパスがあるかをチェック
    vi d(n, INF);
    queue<int> q;
    q.push(n - 2);
    d.at(n - 2) = 0;
    while (!q.empty()) {
        int v = q.front(); q.pop();
        for (auto u: edges.at(v)) {
            if (d.at(u) == INF) {
                q.push(u);
                d.at(u) = d.at(v) + 1;
            } 
        }
    }

    cout << (d.at(n - 1) != INF ? YES : NO) << endl;
    return 0;
}
// struct Med {
//     int r, c, e;
//     Med(int r = 0, int c = 0, int e = 0): r(r), c(c), e(e) {}
// };

// // Generated by 2.13.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
// int main(){
//         // Failed to predict input format
//     int h, w;
//     cin >> h >> w;
//     vector<string> s(h);
//     REP(i, h) cin >> s.at(i);
//     int n;
//     cin >> n;
//     vector<Med> meds(n);
//     REP(i, n) {
//         int r, c, e;
//         cin >> r >> c >> e;
//         r--;
//         c--;
//         meds.at(i) = Med(r, c, e);
//     }

//     int si = 0, sj = 0, ti = 0, tj = 0;
//     REP(i, h) REP(j, w) {
//         if (s.at(i).at(j) == 'S') si = i, sj = j;
//         if (s.at(i).at(j) == 'T') ti = i, tj = j;
//     }

//     // 始点と終点にエネルギー0の薬を配置
//     meds.emplace_back(si, sj, 0);
//     meds.emplace_back(ti, tj, 0);
//     n += 2;
//     int smi = n-2, tmi = n-1;
    
//     const vi dr = {1, 0, -1, 0};
//     const vi dc = {0, 1, 0, -1};

//     vvi to(n); // 薬から薬へのグラフを作成

//     REP(sv, n) {
//         auto [sr, sc, se] = meds[sv];
//         vvi dist(h, vi(w, INF));
//         queue<pii> q;
//         dist.at(sr).at(sc) = 0; q.emplace(sr, sc);
//         while (!q.empty()) {
//             auto [r, c] = q.front(); q.pop();
//             REP(i, 4) {
//                 int nr = r + dr.at(i);
//                 int nc = c + dc.at(i);
//                 if (nr < 0 || nr >= h || nc < 0 || nc >= w ||
//                     s.at(nr).at(nc) == '#' ||
//                     dist.at(nr).at(nc) != INF) continue;
//                 dist.at(nr).at(nc) = dist.at(r).at(c) + 1; q.emplace(nr, nc);
//             }
//         }

//         REP(tv, n) {
//             auto [tr, tc, te] = meds[tv];
//             if (sv == tv) continue;
//             if (dist.at(tr).at(tc) <= se) to.at(sv).push_back(tv);
//         }
//     }

//     // 作成したグラフtoを用いて、smiからtmiへ到達可能かをBFSで判定
//     vi dist(n, INF);
//     queue<int> q;
//     dist[smi] = 0; q.push(smi);
//     while (!q.empty()) {
//         int v = q.front(); q.pop();
//         for (int u: to.at(v)) {
//             if (dist.at(u) != INF) continue;
//             dist.at(u) = dist.at(v) + 1; q.push(u); 
//         }
//     }

//     if (dist.at(tmi) != INF) cout << YES << endl;
//     else cout << NO << endl;

//     return 0;
// }
